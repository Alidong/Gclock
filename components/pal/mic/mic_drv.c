#include "mic_drv.h"
#include "../board.h"
#include "../pal_driver.h"
#include "dsps_fft2r.h"
#include "esp_dsp.h"
#include <math.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "driver/i2s_std.h"
#include "driver/gpio.h"
#include "esp_check.h"

static const char *TAG = "Mic";
#define FFT_SAMPLES               256
#define BUFF_SIZE                FFT_SAMPLES*3             
static i2s_chan_handle_t                rx_chan;        // I2S rx channel handler

// Table of linearNoise results to be multiplied by squelch in order to reduce squelch across fftResult bins.
const int linearNoise[16] = { 34, 28, 26, 25, 20, 12, 9, 6, 4, 4, 3, 2, 2, 2, 2, 2 };
// Table of multiplication factors so that we can even out the frequency response.
// const double fftResultPink[16] = {1.70,1.71,1.73,1.78,1.68,1.56,1.55,1.63,1.79,1.62,1.80,2.06,2.47,3.35,6.83,9.55};
#pragma  pack(4)
static float ffRes[FFT_SAMPLES/4];
// static uint8_t r_buf[3*100];
#pragma pack()
static void i2s_read_task(void *args)
{
    uint8_t *r_buf = (uint8_t *)calloc(1, BUFF_SIZE);
    assert(r_buf); // Check if r_buf allocation success
    size_t r_bytes = 0;
    /* ATTENTION: The print and delay in the read task only for monitoring the data by human,
     * Normally there shouldn't be any delays to ensure a short polling time,
     * Otherwise the dma buffer will overflow and lead to the data lost */
    esp_err_t ret=dsps_fft2r_init_fc32(NULL, FFT_SAMPLES*4);
    if ( ret!= ESP_OK)
    {
        ESP_LOGE(TAG, "Not possible to initialize FFT. Error = %i", ret);
        assert(0);
    }
    while (1) {
        /* Read i2s data */
        if (i2s_channel_read(rx_chan, r_buf, BUFF_SIZE, &r_bytes, portMAX_DELAY) == ESP_OK && r_bytes==BUFF_SIZE) 
        {   
            float fftSamples[FFT_SAMPLES];
            float fftWin[FFT_SAMPLES]; 
            dsps_wind_hann_f32(fftWin, FFT_SAMPLES);
            for (uint16_t i = 0; i < FFT_SAMPLES; i++)
            {
                uint32_t value= (r_buf[3*i])|(r_buf[3*i+1]<<8)|(r_buf[3*i+2]<<16);
                // uint32_t value= (r_buf[3*i])|(r_buf[3*i+1]<<8)|(r_buf[3*i+2]<<16);
                fftSamples[i]=((value))*fftWin[i];
            }
            dsps_fft2r_fc32(fftSamples, FFT_SAMPLES/2);
            dsps_bit_rev_fc32(fftSamples, FFT_SAMPLES/2);
            dsps_cplx2reC_fc32(fftSamples, FFT_SAMPLES/2);
            float* fftSamples1=&fftSamples[0];
            float* fftSamples2=&fftSamples[FFT_SAMPLES/2];
            for (int i = 0 ; i < FFT_SAMPLES/4 ; i++) 
            {
                fftSamples1[i] = 10*log10f((fftSamples1[i * 2 + 0] * fftSamples1[i * 2 + 0] + fftSamples1[i * 2 + 1] * fftSamples1[i * 2 + 1])/(FFT_SAMPLES/2));
                fftSamples2[i] = 10 * log10f((fftSamples2[i * 2 + 0] * fftSamples2[i * 2 + 0] + fftSamples2[i * 2 + 1] * fftSamples2[i * 2 + 1])/(FFT_SAMPLES/2));
                // Simple way to show two power spectrums as one plot
                ffRes[i]=fmax(fftSamples1[i],fftSamples2[i]);
            }
        }   
        else {
            printf("Read Task: i2s read failed\n");
        }
        vTaskDelay(1);
    }
    free(r_buf);
    vTaskDelete(NULL);
}
static void i2s_init(void)
{
    gpio_config_t io_conf = {};
    //disable interrupt
    io_conf.intr_type = GPIO_INTR_DISABLE;
    //set as output mode
    io_conf.mode = GPIO_MODE_OUTPUT;
    //bit mask of the pins that you want to set,e.g.GPIO18/19
    io_conf.pin_bit_mask = (1ULL << PIN_L_R);
    //disable pull-down mode
    io_conf.pull_down_en = 0;
    //disable pull-up mode
    io_conf.pull_up_en = 0;
    //configure GPIO with the given settings
    gpio_config(&io_conf);
    gpio_set_level(PIN_L_R, 1);
    /* Setp 1: Determine the I2S channel configuration and allocate two channels one by one
     * The default configuration can be generated by the helper macro,
     * it only requires the I2S controller id and I2S role
     * The tx and rx channels here are registered on different I2S controller,
     * only ESP32-C3, ESP32-S3 and ESP32-H2 allow to register two separate tx & rx channels on a same controller */
    i2s_chan_config_t rx_chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
    ESP_ERROR_CHECK(i2s_new_channel(&rx_chan_cfg, NULL, &rx_chan));

    /* Step 2: Setting the configurations of standard mode and initialize each channels one by one
     * The slot configuration and clock configuration can be generated by the macros
     * These two helper macros is defined in 'i2s_std.h' which can only be used in STD mode.
     * They can help to specify the slot and clock configurations for initialization or re-configuring */
    i2s_std_config_t rx_std_cfg = {
        .clk_cfg  = { 
            .sample_rate_hz = 10*1000,
            .clk_src = I2S_CLK_SRC_DEFAULT, 
            .mclk_multiple = I2S_MCLK_MULTIPLE_384, 
        },
        .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_24BIT, I2S_SLOT_MODE_MONO),
        .gpio_cfg = {
            .mclk = I2S_GPIO_UNUSED,    // some codecs may require mclk signal, this example doesn't need it
            .bclk = I2S_PIN_SCL,
            .ws   = I2S_PIN_WS,
            .dout = I2S_GPIO_UNUSED,
            .din  = I2S_PIN_SD,
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                .ws_inv   = false,
            },
        },
    };
    /* Default is only receiving left slot in mono mode,
     * update to right here to show how to change the default configuration */
    rx_std_cfg.slot_cfg.slot_mask = I2S_STD_SLOT_RIGHT;
    // rx_std_cfg.slot_cfg.big_endian=true;
    ESP_ERROR_CHECK(i2s_channel_init_std_mode(rx_chan, &rx_std_cfg));
    /* Step 3: Enable the tx and rx channels before writing or reading data */
    //     i2s_event_callbacks_t cb={
    //     .on_recv=i2s_read_cb,
    //     .on_recv_q_ovf=NULL,
    //     .on_send_q_ovf=NULL,
    //     .on_sent=NULL,
    // };
    // i2s_channel_register_event_callback(rx_chan,&cb,NULL);
    ESP_ERROR_CHECK(i2s_channel_enable(rx_chan));
    /* Step 4: Create writing and reading task */
    xTaskCreate(i2s_read_task, "i2s_read_task", 4096, NULL, 5, NULL);
}
void mic_drv_init(void)
{
    i2s_init();
}
bool mic_fft(float* samples ,uint16_t len)
{
    bool res=false;
    if (len==(FFT_SAMPLES/4))
    {
        memcpy(samples,ffRes,len*sizeof(float));
        res=true;
    }
    return res;
}
